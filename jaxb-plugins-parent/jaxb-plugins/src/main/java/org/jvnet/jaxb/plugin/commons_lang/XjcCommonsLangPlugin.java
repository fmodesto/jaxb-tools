/*
 * Copyright 2006 The Apache Software Foundation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License")
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.jvnet.jaxb.plugin.commons_lang;

import java.util.Collection;
import java.util.Map;

import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.commons.lang3.builder.ToStringStyle;
import org.xml.sax.ErrorHandler;

import com.sun.codemodel.JBlock;
import com.sun.codemodel.JClass;
import com.sun.codemodel.JCodeModel;
import com.sun.codemodel.JDefinedClass;
import com.sun.codemodel.JExpr;
import com.sun.codemodel.JExpression;
import com.sun.codemodel.JFieldRef;
import com.sun.codemodel.JInvocation;
import com.sun.codemodel.JMethod;
import com.sun.codemodel.JMod;
import com.sun.codemodel.JOp;
import com.sun.codemodel.JVar;
import com.sun.tools.xjc.BadCommandLineException;
import com.sun.tools.xjc.Options;
import com.sun.tools.xjc.Plugin;
import com.sun.tools.xjc.outline.ClassOutline;
import com.sun.tools.xjc.outline.Outline;

/**
 * Automatically generates the toString(), hashCode() and equals() methods
 * using Jakarta's commons-lang.
 *
 * Supports the optional ToStringStyle command line parameter to specify
 * the style for use within the toString method.
 *
 * <pre>
 * Example 1:
 *
 *     -Xcommons-lang
 *     -Xcommons-lang:ToStringStyle=SIMPLE_STYLE
 *
 *     to specify the use of
 *
 *     org.apache.commons.lang3.builder.ToStringStyle.SIMPLE_STYLE
 *
 * Example 2:
 *
 *     -Xcommons-lang
 *     -Xcommons-lang:ToStringStyle=my.CustomToStringStyle
 *
 *     to specify the use of
 *
 *     my.CustomToStringStyle, which must be a subclass of
 *
 *     org.apache.commons.lang3.builder.ToStringStyle, and contains a public no-arg constructor.
 *
 * </pre>
 *
 * The default ToStringStyle adopted by this plugin is MULTI_LINE_STYLE.
 *
 * @see org.apache.commons.lang3.builder.ToStringStyle
 * @author Hanson Char
 */
public class XjcCommonsLangPlugin extends Plugin
{
    private static final String TOSTRING_STYLE_PARAM = "-Xcommons-lang:ToStringStyle=";
    private static final String USE_BUILDER = "-Xcommons-lang:UseBuilder";
    private String toStringStyle = "MULTI_LINE_STYLE";
    private Class<?> customToStringStyle;
    private boolean useBuilder;

    @Override
    public String getOptionName()
    {
        return "Xcommons-lang";
    }

    @Override
    public String getUsage()
    {
        return "  -Xcommons-lang        :  generate toString(), hashCode() and equals() for generated code using Jakarta's common-lang\n"
             + " [-Xcommons-lang:UseBuilder\n"
             + "  -Xcommons-lang:ToStringStyle=MULTI_LINE_STYLE\n\t"
             + "| DEFAULT_STYLE\n\t"
             + "| NO_FIELD_NAMES_STYLE\n\t"
             + "| SHORT_PREFIX_STYLE\n\t"
             + "| SIMPLE_STYLE\n\t"
             + "| <Fully qualified class name of a ToStringStyle subtype>]\n"
             ;
    }

    @Override
    public boolean run(Outline outline,
        @SuppressWarnings("unused") Options opt,
        @SuppressWarnings("unused") ErrorHandler errorHandler)
    {
        // Process every pojo class generated by jaxb
        for (ClassOutline classOutline : outline.getClasses()) {
            JDefinedClass implClass = classOutline.implClass;
            if (useBuilder) {
                boolean invokeSuper = outline.getClasses().stream()
                    .anyMatch(e -> e.implClass.equals(implClass._extends()));
                this.createToStringMethodWithBuilder(implClass, invokeSuper);
                this.createEqualsMethodWithBuilder(implClass, invokeSuper);
                this.createHashCodeMethodWithBuilder(implClass, invokeSuper);
            } else {
                this.createToStringMethod(implClass);
                this.createEqualsMethod(implClass);
                this.createHashCodeMethod(implClass);
            }
        }
        return true;
    }

    private void createToStringMethod(JDefinedClass implClass)
    {
        JCodeModel codeModel = implClass.owner();
        JMethod toStringMethod =
            implClass.method(JMod.PUBLIC, codeModel.ref(String.class), "toString");
        // Annotate with @Override
        toStringMethod.annotate(Override.class);
        // Invoke ToStringBuilder.reflectionToString(Object,StringStyle)
        toStringMethod.body()
                      ._return(
                              codeModel.ref(ToStringBuilder.class)
                                       .staticInvoke("reflectionToString")
                                       .arg(JExpr._this())
                                       .arg(getStringStyle(codeModel))
                              );
        return;
    }

    private void createToStringMethodWithBuilder(JDefinedClass implClass, boolean invokeSuper)
    {
        JCodeModel codeModel = implClass.owner();
        JMethod toStringMethod =
            implClass.method(JMod.PUBLIC, codeModel.ref(String.class), "toString");
        toStringMethod.annotate(Override.class);

        JBlock body = toStringMethod.body();
        // ToStringBuilder builder = new ToStringBuilder(this, StringStyle);
        JExpression constructor = JExpr._new(codeModel.ref(ToStringBuilder.class))
            .arg(JExpr._this())
            .arg(getStringStyle(codeModel));
        JVar builder = body.decl(codeModel.ref(ToStringBuilder.class), "builder", constructor);
        if (invokeSuper) {
            // builder.appendSuper(super.toString());
            JInvocation appendSuper = builder.invoke("appendSuper")
                .arg(JExpr._super().invoke("toString"));
            body.add(appendSuper);
        }
        for (JVar field : implClass.fields().values()) {
            if (isInstance(field)) {
                // builder.append("field", this.field);
                JInvocation append = builder.invoke("append")
                    .arg(field.name())
                    .arg(JExpr._this().ref(field));
                body.add(append);
            }
        }
        // return builder.build();
        JInvocation build = builder.invoke("build");
        body._return(build);
    }

    private JExpression getStringStyle(JCodeModel codeModel)
    {
        return customToStringStyle == null
            ? codeModel.ref(ToStringStyle.class).staticRef(toStringStyle)
            : JExpr._new(codeModel.ref(customToStringStyle));
    }

    private void createEqualsMethod(JDefinedClass implClass)
    {
        JCodeModel codeModel = implClass.owner();
        JMethod toStringMethod =
            implClass.method(JMod.PUBLIC, codeModel.BOOLEAN, "equals");
        JVar that = toStringMethod.param(Object.class, "that");
        // Annotate with @Override
        toStringMethod.annotate(Override.class);
        // Invoke EqualsBuilder.reflectionEquals(Object,Object);
        toStringMethod.body()._return(
            codeModel.ref(EqualsBuilder.class)
                     .staticInvoke("reflectionEquals")
                     .arg(JExpr._this())
                     .arg(that)
        );
        return;
    }

    private void createEqualsMethodWithBuilder(JDefinedClass implClass, boolean invokeSuper)
    {
        JCodeModel codeModel = implClass.owner();
        JMethod equalsMethod =
            implClass.method(JMod.PUBLIC, codeModel.BOOLEAN, "equals");
        JVar o = equalsMethod.param(Object.class, "o");
        equalsMethod.annotate(Override.class);

        JExpression thisRef = JExpr._this();
        JBlock body = equalsMethod.body();
        // if (this == o) return true;
        body._if(thisRef.eq(o))
            ._then()._return(JExpr.TRUE);
        // if (o == null || this.getClass() != o.getClass()) return false;
        body._if(o.eq(JExpr._null()).cor(thisRef.invoke("getClass").ne(o.invoke("getClass"))))
            ._then()._return(JExpr.FALSE);
        // ImplClass that = (ImplClass) o;
        JVar thatRef = body.decl(implClass, "that", JExpr.cast(implClass, o));
        // EqualsBuilder builder = new EqualsBuilder();
        JExpression constructor = JExpr._new(codeModel.ref(EqualsBuilder.class));
        JVar builder = body.decl(codeModel.ref(EqualsBuilder.class), "builder", constructor);
        if (invokeSuper) {
            // builder.appendSuper(super.equals(that));
            JInvocation appendSuper = builder.invoke("appendSuper")
                .arg(JExpr._super().invoke("equals").arg(thatRef));
            body.add(appendSuper);
        }
        for (JVar field : implClass.fields().values()) {
            if (isInstance(field)) {
                // builder.append(this.field, that.field)
                JInvocation append = builder.invoke("append")
                    .arg(createAccessor(thisRef, field))
                    .arg(createAccessor(thatRef, field));
                body.add(append);
            }
        }
        // return builder.build();
        JInvocation build = builder.invoke("build");
        body._return(build);
    }

    private void createHashCodeMethod(JDefinedClass implClass)
    {
        JCodeModel codeModel = implClass.owner();
        JMethod toStringMethod =
            implClass.method(JMod.PUBLIC, codeModel.INT, "hashCode");
        // Annotate with @Override
        toStringMethod.annotate(Override.class);
        // Invoke EqualsBuilder.reflectionHashCode(Object);
        toStringMethod.body()._return(
            codeModel.ref(HashCodeBuilder.class)
                     .staticInvoke("reflectionHashCode")
                     .arg(JExpr._this())
        );
        return;
    }

    private void createHashCodeMethodWithBuilder(JDefinedClass implClass, boolean invokeSuper)
    {
        JCodeModel codeModel = implClass.owner();
        JMethod hashCodeMethod =
            implClass.method(JMod.PUBLIC, codeModel.INT, "hashCode");
        hashCodeMethod.annotate(Override.class);
        JBlock body = hashCodeMethod.body();
        // HashCodeBuilder builder = new HashCodeBuilder();
        JExpression constructor = JExpr._new(codeModel.ref(HashCodeBuilder.class));
        JVar builder = body.decl(codeModel.ref(HashCodeBuilder.class), "builder", constructor);
        if (invokeSuper) {
            // builder.appendSuper(super.hashCode());
            JInvocation appendSuper = builder.invoke("appendSuper")
                .arg(JExpr._super().invoke("hashCode"));
            body.add(appendSuper);
        }
        for (JVar field : implClass.fields().values()) {
            if (isInstance(field)) {
                // builder.append(this.field);
                JInvocation append = builder.invoke("append")
                    .arg(createAccessor(JExpr._this(), field));
                body.add(append);
            }
        }
        // return builder.build();
        JInvocation build = builder.invoke("build");
        body._return(build);
    }

    private static boolean isInstance(JVar field)
    {
        return (field.mods().getValue() & JMod.STATIC) == 0;
    }

    private JExpression createAccessor(JExpression instance, JVar field)
    {
        JFieldRef ref = instance.ref(field);
        if (field.type() instanceof JClass && isCollection((JClass) field.type())) {
            // this.field == null || this.field.isEmpty() ? null : this.field
            JExpression cond = ref.eq(JExpr._null()).cor(ref.invoke("isEmpty"));
            return JOp.cond(cond, JExpr._null(), ref);
        } else {
            // this.field
            return ref;
        }
    }

    private boolean isCollection(JClass type)
    {
        return type.owner().ref(Collection.class).isAssignableFrom(type.erasure())
            || type.owner().ref(Map.class).isAssignableFrom(type.erasure());
    }

    @Override
    public int parseArgument(Options opt, String[] args, int i)
        throws BadCommandLineException
    {
        // eg. -Xcommons-lang ToStringStyle=SIMPLE_STYLE
        String arg = args[i].trim();

        if (arg.startsWith(TOSTRING_STYLE_PARAM))
        {
            toStringStyle = arg.substring(TOSTRING_STYLE_PARAM.length());
            try {
                ToStringStyle.class.getField(toStringStyle);
                return 1;
            } catch (SecurityException e) {
                throw new BadCommandLineException(e.getMessage());
            } catch (NoSuchFieldException ignore) {
            }
            try {
                customToStringStyle = Class.forName(toStringStyle);
            } catch (ClassNotFoundException e) {
                throw new BadCommandLineException(e.getMessage());
            }
            return 1;
        }
        if (arg.startsWith(USE_BUILDER))
        {
            useBuilder = true;
            return 1;
        }
        return 0;
    }
}
